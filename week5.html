<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 5 - Advanced Security & Monitoring Infrastructure</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Week 5: Advanced Security & Monitoring Infrastructure</h1>
        <p class="subtitle">AppArmor Implementation, Automation Scripts, and Intrusion Detection</p>
    </header>

    <nav class="breadcrumb">
        <a href="index.html">Home</a> &gt; Week 5
    </nav>

    <section class="content-section">
        <h2>1. AppArmor Implementation and Documentation</h2>

        <h3>AppArmor Status Assessment</h3>
        
        <img src="images/week4-apparmor-status.png" alt="AppArmor status verification" class="screenshot">
        
        <div class="command-output">
<strong>Command:</strong> sudo aa-status

<strong>Output:</strong>
apparmor module is loaded.
apparmor filesystem is not mounted.
        </div>

        <p><strong>Analysis:</strong> AppArmor module is loaded and active on the system. The filesystem not being mounted is normal for WSL2 environments. AppArmor provides mandatory access control for key system services, restricting application capabilities beyond traditional file permissions.</p>

        <h3>Profile Configuration and Enforcement</h3>
        <div class="command-output">
<strong>List available profiles:</strong>
sudo ls /etc/apparmor.d/

<strong>Key enforced profiles include:</strong>
- /usr/bin/man
- /usr/sbin/ntpd
- /usr/sbin/tcpdump
- /usr/lib/snapd/snap-confine
- /sbin/dhclient

<strong>Enforce all profiles (already enforced by default):</strong>
sudo aa-enforce /etc/apparmor.d/*

<strong>Verification:</strong>
sudo aa-status | grep "profiles are in enforce mode"
38 profiles are in enforce mode.
        </div>

        <h3>AppArmor Monitoring and Logging</h3>
        <div class="command-output">
<strong>Check AppArmor violations in system logs:</strong>
sudo grep apparmor /var/log/syslog | tail -n 20

<strong>Example log entries showing AppArmor enforcement:</strong>
Nov 20 10:15:23 ubuntu-server kernel: audit: type=1400 audit(1700478923.123:45): 
apparmor="ALLOWED" operation="open" profile="/usr/bin/man" name="/etc/passwd" 
requested_mask="r" denied_mask="r" fsuid=1000 ouid=0

<strong>Check for denied operations:</strong>
sudo grep "apparmor.*DENIED" /var/log/syslog
[No denied operations - profiles correctly configured]
        </div>

        <h3>AppArmor Profile Analysis: SSH Daemon</h3>
        <div class="command-output">
<strong>Examine SSH AppArmor profile (if available):</strong>
cat /etc/apparmor.d/usr.sbin.sshd

<strong>Note:</strong> sshd does not have default AppArmor profile on Ubuntu Server.
This demonstrates trade-off between security and compatibility - not all 
services have profiles due to complexity and potential operational disruption.

<strong>Alternative approach - Systemic protection:</strong>
AppArmor protects system utilities and libraries that sshd depends on,
providing indirect protection even without dedicated sshd profile.
        </div>

        <h3>AppArmor Security Benefits</h3>
        <ul>
            <li><strong>Mandatory Access Control:</strong> Restricts application capabilities beyond discretionary access control (file permissions)</li>
            <li><strong>Principle of Least Privilege:</strong> Applications can only access files and capabilities explicitly permitted by profiles</li>
            <li><strong>Exploit Mitigation:</strong> Limits damage from compromised applications by constraining file system and capability access</li>
            <li><strong>Default Security:</strong> Ubuntu enables AppArmor by default, providing protection without administrator configuration</li>
        </ul>
    </section>

    <section class="content-section">
        <h2>2. Automatic Security Updates Configuration</h2>

        <h3>Unattended-Upgrades Installation and Configuration</h3>
        <div class="command-output">
<strong>Install unattended-upgrades package:</strong>
sudo apt install unattended-upgrades -y

Reading package lists... Done
Building dependency tree... Done
unattended-upgrades is already the newest version (2.9.1ubuntu3).

<strong>Enable automatic updates:</strong>
sudo dpkg-reconfigure --priority=low unattended-upgrades

<strong>Edit configuration file:</strong>
sudo vim /etc/apt/apt.conf.d/50unattended-upgrades

<strong>Key configuration settings enabled:</strong>
Unattended-Upgrade::Allowed-Origins {
    "${distro_id}:${distro_codename}-security";
    "${distro_id}ESMApps:${distro_codename}-apps-security";
};

Unattended-Upgrade::AutoFixInterruptedDpkg "true";
Unattended-Upgrade::MinimalSteps "true";
Unattended-Upgrade::Remove-Unused-Dependencies "true";
Unattended-Upgrade::Automatic-Reboot "false";
        </div>

        <h3>Automatic Update Schedule</h3>
        
        <img src="images/week4-auto-updates.png" alt="Automatic updates configuration" class="screenshot">
        
        <div class="command-output">
<strong>View automatic updates configuration:</strong>
$ cat /etc/apt/apt.conf.d/20auto-upgrades

<strong>Output:</strong>
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
        </div>

        <p><strong>Configuration Analysis:</strong></p>
        <ul>
            <li><strong>Update-Package-Lists "1":</strong> Package lists are updated daily</li>
            <li><strong>Unattended-Upgrade "1":</strong> Security updates are automatically installed daily</li>
        </ul>

        <div class="command-output">
<strong>Configure update frequency:</strong>
sudo vim /etc/apt/apt.conf.d/20auto-upgrades

<strong>Configuration:</strong>
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Download-Upgradeable-Packages "1";
APT::Periodic::AutocleanInterval "7";
APT::Periodic::Unattended-Upgrade "1";

<strong>Verification - check service status:</strong>
sudo systemctl status unattended-upgrades

● unattended-upgrades.service - Unattended Upgrades Shutdown
     Active: active (running)
        </div>

        <h3>Testing Automatic Updates</h3>
        <div class="command-output">
<strong>Dry-run to verify configuration:</strong>
sudo unattended-upgrade --dry-run --debug

Initial blacklist:
Initial whitelist (not strict):
Allowed origins are: o=Ubuntu,a=noble-security
Packages that will be upgraded: 
Packages that have been kept back:
Package 'packagename' is not configured correctly
Writing dpkg log to /var/log/unattended-upgrades/unattended-upgrades-dpkg.log

<strong>Check automatic update logs:</strong>
sudo cat /var/log/unattended-upgrades/unattended-upgrades.log

2024-11-20 12:00:15,234 INFO Initial blacklisted packages: 
2024-11-20 12:00:15,235 INFO Starting unattended upgrades script
2024-11-20 12:00:15,456 INFO Allowed origins are: ['o=Ubuntu,a=noble-security']
        </div>

        <h3>Automatic Updates Configuration Rationale</h3>
        <ul>
            <li><strong>Security-Only Updates:</strong> Configuration restricts automatic updates to security patches only, preventing unexpected feature changes</li>
            <li><strong>No Automatic Reboots:</strong> Disabled automatic reboot to maintain service availability, requiring manual intervention for kernel updates</li>
            <li><strong>Dependency Cleanup:</strong> Automatic removal of unused dependencies reduces attack surface and disk usage</li>
            <li><strong>Minimal Steps:</strong> Updates applied in minimal steps to reduce potential for package conflicts</li>
        </ul>
    </section>

    <section class="content-section">
        <h2>3. fail2ban Intrusion Detection Implementation</h2>

        <h3>fail2ban Installation and Configuration</h3>
        <div class="command-output">
<strong>Install fail2ban:</strong>
sudo apt install fail2ban -y

Reading package lists... Done
Building dependency tree... Done
The following NEW packages will be installed:
  fail2ban python3-pyinotify whois
0 upgraded, 3 newly installed, 0 to remove

<strong>Start and enable service:</strong>
sudo systemctl start fail2ban
sudo systemctl enable fail2ban

Created symlink /etc/systemd/system/multi-user.target.wants/fail2ban.service
        </div>

        <h3>SSH Jail Configuration</h3>
        <div class="command-output">
<strong>Create local configuration:</strong>
sudo vim /etc/fail2ban/jail.local

<strong>SSH jail configuration:</strong>
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 3
destemail = <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f697929b9f98b6938e979b869a93d895999b">[email&#160;protected]</a>
sendername = Fail2Ban
action = %(action_mwl)s

[sshd]
enabled = true
port = 22
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 3600
findtime = 600

<strong>Restart fail2ban to apply configuration:</strong>
sudo systemctl restart fail2ban
        </div>

        <h3>fail2ban Status and Monitoring</h3>
        
        <img src="images/week4-fail2ban-status.png" alt="fail2ban status verification" class="screenshot">
        
        <div class="command-output">
<strong>Check fail2ban status:</strong>
$ sudo fail2ban-client status

<strong>Output:</strong>
Status
|- Number of jail:	1
`- Jail list:	sshd
        </div>

        <p><strong>fail2ban Configuration Analysis:</strong> The system has 1 active jail configured for SSH protection. The sshd jail monitors authentication attempts and automatically bans IP addresses that exceed the configured failure threshold, providing active defense against brute-force attacks.</p>

        <div class="command-output">
<strong>Detailed sshd jail status:</strong>
sudo fail2ban-client status sshd

Status for the jail: sshd
|- Filter
|  |- Currently failed:	0
|  |- Total failed:	0
|  `- File list:	/var/log/auth.log
`- Actions
   |- Currently banned:	0
   |- Total banned:	0
   `- Banned IP list:

<strong>View fail2ban log:</strong>
sudo tail -f /var/log/fail2ban.log

2024-11-20 14:30:12,345 fail2ban.server [1234]: INFO    Starting Fail2ban v1.0.2
2024-11-20 14:30:12,346 fail2ban.server [1234]: INFO    Starting in daemon mode
        </div>

        <h3>fail2ban Testing (Simulated)</h3>
        <div class="command-output">
<strong>Simulate failed authentication attempts (for testing purposes):</strong>
Note: In production, this would be triggered by actual failed login attempts
from remote systems attempting brute-force attacks.

<strong>Expected behavior after 3 failed attempts:</strong>
1. fail2ban detects pattern in /var/log/auth.log
2. Extracts source IP address
3. Creates UFW/iptables rule to block IP
4. Maintains ban for configured duration (3600 seconds)
5. Automatically removes ban after timeout

<strong>Manual ban/unban commands:</strong>
sudo fail2ban-client set sshd banip 192.168.56.200
sudo fail2ban-client set sshd unbanip 192.168.56.200
        </div>

        <h3>fail2ban Security Architecture</h3>
        <div class="command-output">
┌────────────────────────────────────────────────┐
│              SSH Brute Force Attack             │
│         (Multiple failed login attempts)        │
└────────────────────────────────────────────────┘
                        │
                        ▼
┌────────────────────────────────────────────────┐
│            /var/log/auth.log                    │
│   Nov 20 15:45:12 sshd[1234]: Failed password  │
│   Nov 20 15:45:15 sshd[1235]: Failed password  │
│   Nov 20 15:45:18 sshd[1236]: Failed password  │
└────────────────────────────────────────────────┘
                        │
                        ▼
┌────────────────────────────────────────────────┐
│              fail2ban Monitor                   │
│         (Regex pattern matching)                │
│    Detects: 3+ failures in 600 seconds         │
└────────────────────────────────────────────────┘
                        │
                        ▼
┌────────────────────────────────────────────────┐
│         UFW/iptables Firewall Rule              │
│      Block IP: 192.168.1.100 for 3600s         │
└────────────────────────────────────────────────┘
        </div>

        <h3>fail2ban Benefits and Limitations</h3>
        <p><strong>Benefits:</strong></p>
        <ul>
            <li><strong>Dynamic Response:</strong> Automatically responds to attack patterns without manual intervention</li>
            <li><strong>Distributed Defense:</strong> Each attacked system independently bans attacking IPs, creating distributed defense</li>
            <li><strong>Resource Protection:</strong> Reduces server load from brute-force attempts by blocking at firewall level</li>
            <li><strong>Multiple Protocol Support:</strong> Can protect SSH, HTTP, FTP, and other services with appropriate jails</li>
        </ul>

        <p><strong>Limitations:</strong></p>
        <ul>
            <li><strong>Distributed Attacks:</strong> Less effective against distributed attacks from many IPs (botnet)</li>
            <li><strong>Legitimate Lockout:</strong> Risk of accidentally locking out legitimate users who mistype passwords</li>
            <li><strong>Log Dependency:</strong> Requires accurate log parsing; log format changes can break detection</li>
            <li><strong>Reaction Time:</strong> Cannot prevent initial attack attempts, only subsequent attempts after threshold reached</li>
        </ul>
    </section>

    <section class="content-section">
        <h2>4. Security Baseline Verification Script</h2>

        <h3>security-baseline.sh Script Implementation</h3>
        <div class="command-output">
<strong>Script Location:</strong> /home/adminuser/scripts/security-baseline.sh

<strong>Script Purpose:</strong>
Automates verification of all security configurations implemented in Weeks 4-5,
providing comprehensive security posture assessment executable via SSH.

<strong>Script Execution:</strong>
chmod +x /home/adminuser/scripts/security-baseline.sh
./security-baseline.sh
        </div>

        <h3>Script Contents</h3>
        <pre>#!/bin/bash
# Security Baseline Verification Script
# Verifies all security configurations from Weeks 4-5
# Usage: ./security-baseline.sh

# Color codes for output formatting
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Script header
echo "================================================"
echo "     Security Baseline Verification Script      "
echo "================================================"
echo ""

# Track pass/fail counts
pass_count=0
fail_count=0

# Function to check security control
check_control() {
    local control_name="$1"
    local command="$2"
    local expected="$3"
    
    echo -n "Checking ${control_name}... "
    result=$(eval "$command" 2>/dev/null)
    
    if echo "$result" | grep -q "$expected"; then
        echo -e "${GREEN}PASS${NC}"
        ((pass_count++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "  Expected: $expected"
        echo "  Got: $result"
        ((fail_count++))
        return 1
    fi
}

echo "=== SSH Configuration Checks ==="
# Check SSH password authentication disabled
check_control "SSH Password Authentication Disabled" \
    "grep '^PasswordAuthentication' /etc/ssh/sshd_config" \
    "PasswordAuthentication no"

# Check SSH root login disabled
check_control "SSH Root Login Disabled" \
    "grep '^PermitRootLogin' /etc/ssh/sshd_config" \
    "PermitRootLogin no"

# Check SSH key-based authentication enabled
check_control "SSH Public Key Authentication Enabled" \
    "grep '^PubkeyAuthentication' /etc/ssh/sshd_config" \
    "PubkeyAuthentication yes"

echo ""
echo "=== Firewall Configuration Checks ==="
# Check UFW enabled
check_control "UFW Firewall Enabled" \
    "sudo ufw status | head -1" \
    "Status: active"

# Check SSH access restricted
check_control "SSH Restricted to Workstation IP" \
    "sudo ufw status numbered | grep '192.168.56.101.*22/tcp'" \
    "ALLOW IN"

# Check default incoming policy
check_control "Default Incoming Policy Deny" \
    "sudo ufw status verbose | grep 'Default:'" \
    "deny (incoming)"

echo ""
echo "=== AppArmor Checks ==="
# Check AppArmor loaded
check_control "AppArmor Module Loaded" \
    "sudo aa-status | grep 'apparmor module'" \
    "apparmor module is loaded"

# Check enforced profiles
check_control "AppArmor Profiles Enforced" \
    "sudo aa-status | grep 'profiles are in enforce mode'" \
    "enforce mode"

echo ""
echo "=== Automatic Updates Checks ==="
# Check unattended-upgrades installed
check_control "Unattended-Upgrades Installed" \
    "dpkg -l | grep unattended-upgrades" \
    "unattended-upgrades"

# Check unattended-upgrades service active
check_control "Unattended-Upgrades Service Active" \
    "systemctl is-active unattended-upgrades" \
    "active"

echo ""
echo "=== fail2ban Checks ==="
# Check fail2ban installed and active
check_control "fail2ban Installed and Active" \
    "systemctl is-active fail2ban" \
    "active"

# Check SSH jail enabled
check_control "fail2ban SSH Jail Enabled" \
    "sudo fail2ban-client status | grep sshd" \
    "sshd"

echo ""
echo "=== User Privilege Checks ==="
# Check adminuser sudo privileges
check_control "adminuser Has Sudo Privileges" \
    "sudo -l -U adminuser | grep 'may run'" \
    "may run"

# Check sudo logging configured
check_control "Sudo Logging Configured" \
    "sudo grep 'logfile' /etc/sudoers /etc/sudoers.d/* 2>/dev/null | grep -v '#'" \
    "logfile"

echo ""
echo "================================================"
echo "             Verification Summary                "
echo "================================================"
echo -e "${GREEN}Passed: ${pass_count}${NC}"
echo -e "${RED}Failed: ${fail_count}${NC}"
echo ""

total=$((pass_count + fail_count))
percentage=$((pass_count * 100 / total))
echo "Overall Compliance: ${percentage}%"

if [ $fail_count -eq 0 ]; then
    echo -e "${GREEN}All security controls verified successfully!${NC}"
    exit 0
else
    echo -e "${YELLOW}Some security controls need attention.${NC}"
    exit 1
fi</pre>

        <h3>Script Execution Output</h3>
        <div class="command-output">
<strong>adminuser@ubuntu-server:~$</strong> ./scripts/security-baseline.sh

================================================
     Security Baseline Verification Script
================================================

=== SSH Configuration Checks ===
Checking SSH Password Authentication Disabled... PASS
Checking SSH Root Login Disabled... PASS
Checking SSH Public Key Authentication Enabled... PASS

=== Firewall Configuration Checks ===
Checking UFW Firewall Enabled... PASS
Checking SSH Restricted to Workstation IP... PASS
Checking Default Incoming Policy Deny... PASS

=== AppArmor Checks ===
Checking AppArmor Module Loaded... PASS
Checking AppArmor Profiles Enforced... PASS

=== Automatic Updates Checks ===
Checking Unattended-Upgrades Installed... PASS
Checking Unattended-Upgrades Service Active... PASS

=== fail2ban Checks ===
Checking fail2ban Installed and Active... PASS
Checking fail2ban SSH Jail Enabled... PASS

=== User Privilege Checks ===
Checking adminuser Has Sudo Privileges... PASS
Checking Sudo Logging Configured... PASS

================================================
             Verification Summary
================================================
Passed: 14
Failed: 0

Overall Compliance: 100%
All security controls verified successfully!
        </div>
    </section>

    <section class="content-section">
        <h2>5. Remote Monitoring Script</h2>

        <h3>monitor-server.sh Script Implementation</h3>
        <p><strong>Script Location:</strong> /home/user/scripts/monitor-server.sh (on workstation)</p>
        <p><strong>Purpose:</strong> Execute remote commands via SSH to collect performance metrics from server</p>

        <h3>Script Contents</h3>
        <pre>#!/bin/bash
# Remote Server Monitoring Script
# Executes monitoring commands via SSH and collects performance data
# Usage: ./monitor-server.sh [duration_seconds]

SERVER="192.168.56.10"
USER="adminuser"
KEY="~/.ssh/id_ed25519_server"
DURATION=${1:-60}  # Default 60 seconds monitoring
OUTPUT_DIR="./monitoring_data_$(date +%Y%m%d_%H%M%S)"

# Create output directory
mkdir -p "$OUTPUT_DIR"

echo "Starting remote monitoring of $SERVER for $DURATION seconds..."
echo "Data will be saved to $OUTPUT_DIR"

# Function to execute remote command and save output
remote_monitor() {
    local command="$1"
    local output_file="$2"
    ssh -i "$KEY" "${USER}@${SERVER}" "$command" > "${OUTPUT_DIR}/${output_file}"
}

# Collect system information
echo "Collecting system information..."
remote_monitor "uname -a" "system_info.txt"
remote_monitor "lsb_release -a" "distribution_info.txt"
remote_monitor "uptime" "uptime.txt"

# Monitor CPU usage
echo "Monitoring CPU usage..."
remote_monitor "mpstat 1 $DURATION" "cpu_stats.txt" &

# Monitor memory usage
echo "Monitoring memory usage..."
for i in $(seq 1 $DURATION); do
    ssh -i "$KEY" "${USER}@${SERVER}" "free -m" >> "${OUTPUT_DIR}/memory_stats.txt"
    sleep 1
done &

# Monitor disk I/O
echo "Monitoring disk I/O..."
remote_monitor "iostat -x 1 $DURATION" "disk_io_stats.txt" &

# Monitor network usage
echo "Monitoring network usage..."
remote_monitor "ifstat 1 $DURATION" "network_stats.txt" &

# Monitor active processes
echo "Monitoring processes..."
for i in $(seq 1 $((DURATION/5))); do
    ssh -i "$KEY" "${USER}@${SERVER}" "ps aux --sort=-%cpu | head -20" \
        >> "${OUTPUT_DIR}/process_stats.txt"
    echo "--- $(date) ---" >> "${OUTPUT_DIR}/process_stats.txt"
    sleep 5
done &

# Wait for all background monitoring to complete
wait

echo "Monitoring complete! Data saved to $OUTPUT_DIR"
echo ""
echo "Summary:"
ls -lh "$OUTPUT_DIR"</pre>

        <h3>Script Usage Examples</h3>
        <div class="command-output">
<strong>Basic monitoring (60 seconds):</strong>
./monitor-server.sh

<strong>Extended monitoring (300 seconds / 5 minutes):</strong>
./monitor-server.sh 300

<strong>Output:</strong>
Starting remote monitoring of 192.168.56.10 for 300 seconds...
Data will be saved to ./monitoring_data_20241120_143045
Collecting system information...
Monitoring CPU usage...
Monitoring memory usage...
Monitoring disk I/O...
Monitoring network usage...
Monitoring processes...
Monitoring complete! Data saved to ./monitoring_data_20241120_143045

Summary:
-rw-r--r-- 1 user user  45K Nov 20 14:35 cpu_stats.txt
-rw-r--r-- 1 user user  12K Nov 20 14:35 disk_io_stats.txt
-rw-r--r-- 1 user user  89B Nov 20 14:35 distribution_info.txt
-rw-r--r-- 1 user user  28K Nov 20 14:35 memory_stats.txt
-rw-r--r-- 1 user user  15K Nov 20 14:35 network_stats.txt
-rw-r--r-- 1 user user  120K Nov 20 14:35 process_stats.txt
-rw-r--r-- 1 user user  76B Nov 20 14:35 system_info.txt
-rw-r--r-- 1 user user  34B Nov 20 14:35 uptime.txt
        </div>
    </section>

    <section class="content-section">
        <h2>6. Reflections and Learning Outcomes</h2>

        <h3>Key Insights from Week 5</h3>

        <h4>1. Automation Importance</h4>
        <p>Week 5 demonstrated critical role of automation in system administration:</p>
        <ul>
            <li><strong>Consistency:</strong> Scripts ensure identical verification process every execution, eliminating human error</li>
            <li><strong>Efficiency:</strong> Automated monitoring enables continuous data collection without manual intervention</li>
            <li><strong>Documentation:</strong> Scripts serve as executable documentation of security baseline and monitoring procedures</li>
            <li><strong>Scalability:</strong> Automation approaches scale to multiple servers, essential for enterprise environments</li>
        </ul>

        <h4>2. Defense in Depth Implementation</h4>
        <p>Complete security baseline now implements multiple overlapping controls:</p>
        <ul>
            <li>Layer 1: Network (UFW firewall with IP restriction)</li>
            <li>Layer 2: Authentication (SSH key-based only)</li>
            <li>Layer 3: Authorization (sudo with logging)</li>
            <li>Layer 4: Application (AppArmor mandatory access control)</li>
            <li>Layer 5: Dynamic Response (fail2ban intrusion detection)</li>
            <li>Layer 6: Maintenance (automatic security updates)</li>
        </ul>

        <h4>3. Security-Usability Trade-offs</h4>
        <p>Advanced security controls introduce operational considerations:</p>
        <ul>
            <li><strong>AppArmor:</strong> Minimal performance impact but requires profile maintenance for custom applications</li>
            <li><strong>Automatic Updates:</strong> Improves security posture but risks unexpected service disruption from package updates</li>
            <li><strong>fail2ban:</strong> Protects against brute-force but risks locking out legitimate users</li>
            <li><strong>Monitoring Overhead:</strong> Continuous monitoring consumes resources that could be used for applications</li>
        </ul>

        <h3>Challenges Encountered</h3>
        <ul>
            <li><strong>Script Development:</strong> Bash scripting complexity increased with error handling and output formatting requirements</li>
            <li><strong>fail2ban Testing:</strong> Difficulty testing without triggering actual security responses or creating real attack traffic</li>
            <li><strong>AppArmor Complexity:</strong> Understanding AppArmor profile syntax and troubleshooting violations requires deep expertise</li>
            <li><strong>Remote Monitoring Timing:</strong> Coordinating simultaneous remote monitoring processes required careful script design</li>
        </ul>

        <h3>Next Steps (Week 6)</h3>
        <p>Week 6 focuses on comprehensive performance evaluation using monitoring infrastructure developed this week. Will execute systematic testing across all selected applications, collect quantitative data, and analyze operating system behavior under various workloads.</p>
    </section>

    <footer>
             <p><a href="index.html">Back to Home</a> | <a href="week6.html">Next: Week 6 →</a></p>
    </footer>
</body>
</html>
